# odin-nodejs-photo-tagging-app

## Challenges

- Since this was a project with one client and server (opposed to multiple clients), I decided to make everything all within one parent folder, server, clients, everything. I am not finished yet, and can tell you this is a bad idea. Just navigating the folder to find what I need is a pain. The increased mental load of having everything there all the time, instead of hidden away when I am not working on it. I am not a fan of this way of working. So this was an experiment in project structure which has achieved a clear result: doing this is bad, don't do it.
- Learning how to do integration tests with docker and docker-compose was a pain but now I am used to it, it is convenient and provides a lot of confidence that the API is working as intended.
- I also had the idea to have a js file that loads all the environment variables needed for the application and checks they exist. If they don't exist, it throws an error with a message containing details as to what env variables are missing. The idea was to produce more useful errors if the application is run with missing env variables. Without this, the application would give pretty cryptic error messages. This was also useful to avoid having to do the dotenv config in nested packages. Since the server isn't in the root of the project, but the env file is in the root of the project, it had to be told where the env file was and it was kind of fiddly. Initially, the file also exported all the env variables and the rest of the application would import them. However, this turned out to be a bad idea - since if the env variable changes (e.g. the application itself may change the variables), this isn't reflected in the exported variables; they are immutable. So, in the future, just have a script that checks the variables exist and gives warnings/throws errors. Perhaps there could even be an env variable to choose whether to just warn about missing env variables or throw errors and prevent the application running. It has been very useful during deployment to make sure all the required env variables are present, instead of getting cryptic errors.
- Initially, I thought, "I'll only need an admin mode when the application is being set up, so I will just set the environment variable IS_ADMIN to true, add the photos and tags with the app, and then set IS_ADMIN to false and re-deploy". I thought it would save time. This was an error on two fronts: firstly, I didn't read the project brief properly. Sessions were required to keep track of what tags the user has selected, and so the user can set a time once all tags have been found. Secondly, this value gets "baked in" to the docker image in the build process. This ended up being a huge problem during testing with docker. The build process gets done, then the docker image being used for the tests is either the admin or user version and cannot be changed. The solution: implement sessions, like I should have done in the first place.
- Once I had implemented sessions, a integration test kept failing. This only happened when I changed the session middleware's store from the dev-only, leaky MemoryStore to a proper production-ready store. I could not figure out what it was out that one change that would cause a completely unrelated test to fail. The answer: a bug in supertest, or in superagent which it is built upon. "Double callback bug"? After much searching, I found someone else that had similar problems on github and their solution was... to write their own http request tester: Sagetest. So I switched to that, and it not only doesn't suffer from that bug which broke my test, but the send() method actually works as expected. You can provide a js object as the parameter and it works. Supertest's documentation says it should work like that too, but it doesn't. I could only get it to work with a string formatted like a url query. So, I'll be using Sagetest from now on.

## New Stuff That Was Learned By Me

- Integration testing with Docker and docker-compose.
- JSDoc when making npm packages, to get those sweet code suggestions and autocomplete.
- A bit more advanced shell scripting in the process of creating the integration tests.
- Creating more npm packages and running integration tests with them. I made two npm packages in the process of doing this project: @rubicon2/object-transformer and @rubicon2/object-transformer-prisma. These transform objects according to a ruleset provided by the user and the prisma package is a set of common rules and options to use with prisma. I previously made a package called url-query-to-prisma but it was far too limited in what it could do. I needed something more flexible. With object-transformer-prisma in particular, I wanted integration tests to test each rule against a real case of hitting a database with the prisma client.
- Typescript. I was at first hesitant to learn this since you are locked into an extra build step. But alas. I may never go back now. I have written lots of tests for type checking previously, which would be just totally unnecessary with typescript. Prop validation for react really pushed me over the edge there. Looked at prop-types package, which turned out to be deprecated in favour of typescript type checking. So went back and retrofitted typescript onto the vite setup (which was a pain), and now is working well.
